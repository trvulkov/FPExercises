#lang racket
; Упражнение 6:
; Теория:
; Още функции за работа със списъци:
; 1) (take xs n) - взима първите n елемента на списък
(define (take xs n)
  (cond [(null? xs) `()]
        [(<= n 0)   `()]
        [else       (cons (car xs) (take (cdr xs) (- n 1)))]))

;(take `(1 2 3 4 5) 0) ; -> '()
;(take `(1 2 3 4 5) 3) ; -> '(1 2 3)
;(take `(1 2 3 4 5) 7) ; -> '(1 2 3 4 5)
; вграденият take работи по подобен начин, но не може да вземе повече елемента от колкото има в списъка. В последния пример ще даде contract violation  expected: a list with at least 7 elements  given: '(1 2 3 4 5)


; 2) (drop xs n) - премахва първите n елемента на списък
(define (drop xs n)
  (cond [(null? xs) `()]
        [(<= n 0)   xs]
        [else       (drop (cdr xs) (- n 1))]))

;(drop `(1 2 3 4 5) 0) ; -> '(1 2 3 4 5)
;(drop `(1 2 3 4 5) 3) ; -> '(4 5)
;(drop `(1 2 3 4 5) 7) ; -> '()
; отново вграденият drop не може да drop-не повече елемента от колкото има в списъка, и в последния пример ще даде drop: contract violation  expected: a list with at least 7 elements  given: '(1 2 3 4 5)

; 3) (zip xs ys) - връща списък от двойки (Ai,Bi), където Ai е i-тия елемент на xs, Bi е i-тия елемент на ys
; ако списъците са с различна дължина, резултата е с дължината на по-късия от аргументите
(define (zip xs ys)
  (cond [(null? xs) `()]
        [(null? ys) `()]
        [else (cons (cons (car xs) (car ys)) (zip (cdr xs) (cdr ys)))]))

; (zip `(1 2 3 4) `(a b c)) ; -> '((1 . a) (2 . b) (3 . c))

; take и drop са вградени в езика,
; но zip не е (вградена е в Haskell, където има отделен тип за n-торка, в частност 2-орка, т.е. двойка)

; Функции от по-висок ред за работа със списъци:

; 1) (any? pred? xs) - проверява дали поне един елемент на списъка удовлетворява даден предикат
(define (any? pred? xs)
  (if (null? xs)
      #f
      (or (pred? (car xs)) (any? pred? (cdr xs)))))

;(any? odd? `(1 2 3 4 5 6)) ; -> #t
;(any? odd? `(2 4 6))       ; -> #f

; 2) (all? pred? x) - проверява дали всеки елемент на списъка удовлетворява даден предикат
(define (all? pred? xs)
  (if (null? xs)
      #t
      (and (pred? (car xs)) (all? pred? (cdr xs)))))

;(all? odd? `(1 2 3 4 5 6)) ; -> #f
;(all? odd? `(1 3 5))       ; -> #t

; В Racket има вградени функции ormap и andmap, които също извършват подобно действие, но имат и някои допълнителни детайли.
; В Haskell си има any и all (без въпросителните накрая, тъй като там липсва тази конвенция за предикати)

;(ormap odd? `(1 2 3 4 5 6))  ; -> #t
;(ormap odd? `(2 4 6))        ; -> #f
;(andmap odd? `(1 2 3 4 5 6)) ; -> #f
;(andmap odd? `(1 3 5))       ; -> #t

; 3) (map f xs) - прилага f към всеки елемент на xs
; Например ако xs -> `(a b c), то (map f xs) -> `((f a) (f b) (f c))
(define (myMap f xs)
  (if (null? xs)
      `()
      (cons (f (car xs)) (myMap f (cdr xs)))))

;(map sqr `(1 2 3 4 5))             ; -> '(1 4 9 16 25)
;(map (λ (x) (+ x 1)) `(1 2 3 4 5)) ; -> '(2 3 4 5 6)

; вграденият map може да работи и с повече аргументи (стига функцията, която му е подадена също да може)
;(map cons `(1 2 3) `(4 5 6)) ; -> '((1 . 4) (2 . 5) (3 . 6)) (същото като zip)
;(map list `(1 2 3) `(4 5 6) `(7 8 9) `(10 11 12)) ; -> '((1 4 7 10) (2 5 8 11) (3 6 9 12))

; 4) (filter p xs) - премахва (филтрира) елементите, за които предикатът p е грешен
(define (filter p xs)
  (cond [(null? xs)   `()]
        [(p (car xs)) (cons (car xs) (filter p (cdr xs)))]
        [else         (filter p (cdr xs))]))

;(filter odd? `(1 2 3 4 5))            ; -> '(1 3 5)
;(filter (λ (x) (> x 2)) `(1 2 3 4 5)) ; -> '(3 4 5)

; 5) (apply f xs) - връша оценката на f със аргументи - елементите на списъка
; т.е. (apply f `(a b c)) -> (f a b c)

;(apply + `(1 2 3 4)) ; -> (+ 1 2 3 4) -> 10
;(apply * `(1 2 3 4)) ; -> (* 1 2 3 4) -> 24
;(apply * `(0 1 2 3)) ; -> (* 0 1 2 3) -> 0
;(apply append `((1 2 3) () (4 5 6) (7) (8 9))) ; -> '(1 2 3 4 5 6 7 8 9)

; използвайки map и append, може да направим друга дефиниция на filter
(define (filter2 p xs)
  (apply append (map (λ (x) (if (p x) (list x) `())) xs)))
; map с тази ламбда функция ще замени всеки елемент със списък - празен за тези, за които предиката не е верен
;                                                              - с 1 елемент за тези, за които предиката е верен
; apply append ще конкатенира всички тези списъци - празните ще изчезнат и ще останат само елементите, за които предиката е верен
;(filter2 odd? `(1 2 3 4 5)) ; -> '(1 3 5)

; 6) foldl, foldr - обхождане на списък с последователно прилагане на f
; foldr обхожда отдясно наляво, а foldl отляво надясно
(define (foldr f init xs) ; init е начална/нулева стойност. Например при fold-ване с + най-вероятно ще е 0, а при * ще бъде 1
  (if (null? xs)
      init
      (f (car xs) (foldr f init (cdr xs)))))

;(foldr + 0 `(1 2 3 4)) ; -> 10
;(foldr * 0 `(1 2 3 4)) ; -> 0
;(foldr * 1 `(1 2 3 4)) ; -> 24
;(foldr max 0 `(1 2 3 2 5 4 3)) ; -> 5

(define (foldl f init xs)
  (if (null? xs)
      init
      (foldl f (f init (car xs)) (cdr xs))))

;(foldr - 0 `(1 2 3 4)) ; -> -2
;(foldl - 0 `(1 2 3 4)) ; -> -10
; Защо резултатите са различни?
; (foldr - 0 `(1 2 3 4))
; -> 1 - (2 - (3 - (4 - 0))) ; bracketing to the RIGHT
; -> 1 - (2 - (3 - 4))
; -> 1 - (2 - (-1))
; -> 1 - 3
; -> -2

; (foldl - 0 `(1 2 3 4)) 
; -> (((0 - 1) - 2) - 3) - 4 ; bracketing to the LEFT
; -> ((-1 - 2) - 3) - 4
; -> (-3 - 3) - 4
; -> -6 - 4
; -> -10

; при асоциативна и комутативна операция (като +) не би трябвало да има разлика, тъй като скобите и аргументите може да се подредят по произволен начин 
;(foldr + 0 `(1 2 3 4)) ; -> 10
;(foldl + 0 `(1 2 3 4)) ; -> 10

; вграденият foldl всъщност работи по различен начин (https://stackoverflow.com/questions/42144068/how-do-foldl-and-foldr-work-broken-down-in-an-example)
;(foldl - 0 `(1 2 3 4))
; ако закоментираме нашия foldl, за да се извика вградения, ще получим 2, тъй като
; (4 - (3 - (2 - (1 - 0)))) -> 2
; нашите реализации са подобни на тези в Haskell, но в Racket е взето друго решение за левия фолд (https://stackoverflow.com/questions/8778492/why-is-foldl-defined-in-a-strange-way-in-racket)

; може да ползваме fold при дефиниране на някои минали функции
(define (appendWithFold xs ys)
  (foldr cons ys xs))

;(appendWithFold `(1 2 3) `(4 5 6)) ; -> `(1 2 3 4 5 6)


; 7) (zipWith f xs ys) - връща списък с елементи функцията f приложена към елемент на xs и елемент на ys
; т.е. списък от (f Ai Bi), където Ai е i-тия елемент на xs, Bi е i-тия елемент на ys
; отново ако списъците са с различна дължина, резултата е с дължината на по-късия от аргументите
(define (zipWith f xs ys)
  (cond [(null? xs) `()]
        [(null? ys) `()]
        [else (cons (f (car xs) (car ys)) (zipWith f (cdr xs) (cdr ys)))]))

; (zipWith + `(1 2 3) `(4 5 6))         ; -> '((+ 1 4) (+ 2 5) (+ 3 6)) -> '(5 7 9)
; (zipWith * `(0 1 2 3) `(2 2 2 2 2 2)) ; -> '(0 2 4 6)
; (zipWith cons `(1 2 3 4) `(a b c))    ; -> '((1 . a) (2 . b) (3 . c)), т.е същото като обикновения zip

; map, filter, apply и foldl/foldr са вградени в езика,
; any?, all? и zipWith не са (вградени са в Haskell), но за any? и all? може да се ползват ormap и andmap


; няколко примера на curry със списъци
;(all? (curry < 4) '(5 6 7 8))    ; -> #t (дали всички елементи са по-големи от 4 (дали 4 е по-малко от всички елементи))
;(all? (curry > 5) '(4 5 6 7 8))  ; -> #f (дали всички елементи са по-малки от 5)
;(any? (curry > 7) '(5 6 7 8))    ; -> #t (дали има поне един елемент който е по-малък от 7)
;(any? (curry > 4) '(5 6 7 8))  ; -> #f (дали има поне един елемент който е по-малък от 4)

; броя на елементите на списъка, които са по-малки от 5
;(length (filter (curry < 5) `(1 2 3 4 5 6 7 8 9 10))) ; -> 5

; може да комбинираме функциите от по-висок ред, например:
;(foldl + 0 (filter (curry < 20) (map sqr `(1 2 3 4 5 6 7 8)))) ; -> 174 (25 + 36 + 49 + 64 == 5^2 + 6^2 + 7^2 + 8^2)

; друг интересен пример - транспониране на матрица на един ред
(define (transpose xss) (apply map list xss))
; предстаяваме матрицата като списък от списъци с еднаква дължина
(transpose `((1 2 3)
             (4 5 6)
             (7 8 9)))
; -> '((1 4 7) (2 5 8) (3 6 9)), или като го форматираме по-добре
; '((1 4 7)
;   (2 5 8)
;   (3 6 9))
; Как се получава това? По-горе видяхме пример за вградения map, ползван с функцията list и няколко списъка.
;(map list `(1 2 3) `(4 5 6) `(7 8 9)) ; -> '((1 4 7) (2 5 8) (3 6 9))
; в transpose имаме само един списък, но той самият съдържа списъци. Чрез apply може да вземем тези списъци като аргументи на map, и да получим точно горният пример