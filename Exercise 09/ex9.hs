-- коментар на един ред
{-  коментар
    на
    много
    редове -}

-- в Haskell включването на библиотеки става с import
import Data.Char
-- може вместо цяла библиотека да вземем само някои функции от нея
import Data.Char(ord, chr)

-- Haskell е строго типизиран език, за разлика от Racket. Тук трябва типовете да са известни при компилация, и не може функция да връща различен тип в различни ситуации.
-- Езикът обаче има доста силен type inference, който позволява на компилатора в някои ситуации да определи типовете дори и да не са декларирани експлицитно
-- (като auto в C++, обаче не се налага да пишем нищо - просто ако изпуснем типовете, компилатора ще знае директно че оставяме на него работата да ги определи).

-- дефиниция на променлива без тип - компилатора ще я определи като цяло число
a = 5

-- дефиниция на променлива с посочване на типа - става чрез синтаксиса <име> :: <тип>
b :: Int
b = 6
--b = 7 -- error: Multiple declarations of `b'

-- дефиниция на функция на един аргумент без посочване на типа
f1 x = x + 1
-- Ползваме '=' за да разделим името и аргументите от тялото. Тук нямаме обграждане в скоби на всеки израз.
-- Вече за аритметичните операции ползваме стандартен инфиксен запис, за разлика от префиксния в Racket.

-- type inference-а работи и за функции
-- Тук например 1 ще се знае че е цяло число, и освен това, тъй като езикът е строго типизиран, операцията '+' работи само ако и двата и аргумента са с еднакви типове.
-- За разлика от C++, тук не стават имплицитни конвертирания на типове (трябва експлицитно да викаме специфични функции когато се налага, ще видим една от тях след малко),
-- поради което се знае че със сигурност другия аргумент на '+' също трябва да е цяло число. Така определяме че x е цяло, а резултатът на '+' на цели също трябва да е цяло,
-- откъдето получаваме и типът на връщане на функцията.

-- дефиниция на съшата функция на един аргумент като по-горе, но с посочване на типовете - приема Int и връща Int
f2 :: Int -> Int
f2 x = x + 1

-- дефиниция на функция на 3 аргумента от тип Int, която връща Int
f3 :: Int -> Int -> Int -> Int
f3 x y z = x + y + z
-- Синтаксисът може да изглежда леко странен, тъй като няма ясно разделяне между аргументи и резултат. По-нататък ще вникнем защо е така
-- (spoiler: всяка функция в Haskell всъщност е на един аргумент), засега просто помнете че последното нещо е резултатът, всичко друго е аргумент.

-- Като цяло когато типовете се подразбират, не е нужно да се правят типови декларации. Аз все пак в повечето случаи ще ги правя, и ви съветвам вие също да ги правите - така
-- ще е по-ясно какво прави функцията, и ще получавате по-полезни съобщения за грешка. Изключения ще правя основно при локално дефинирани функции - те най-вероятно ще получават
-- аргументи от функцията, в която са дефинирани, а тя ще има типова декларация и съответно типовете вече ще са изяснени.

{- вградени типове и операции в Haskell
Bool - True, False
     - операции: &&, ||, not
     
Int     - цели числа, представени в 32 бита
Integer - цели числа с неограничена точност
        - операции: +, -, *, ^, div/mod (като quotient/remainder в Racket)
        - операции за сравнения: <, <=, >, >=, ==, /= (различно, като != в C++)
        
Float  - числа с плаваща точка
Double - числа с плаваща точка с двойна точност
       - операции: +, -, *, /, ^ (повдигане на степен цяло неотрицателно число), ** (повдигане на произволна степен), sqrt
       - операции за сравнения: <, <=, >, >=, ==, /=
       - закръгляне до цяло - ceiling, floor, round
       - превръщане на цяло в реално - fromIntegral
Макар и аритметичните операции за цели и реални числа да изглеждат еднакво, все пак не могат да се смесват типове.
Ако ще събираме цяло и реално, или ще делим цяло на реално, трябва първо цялото да го конвертираме експлицитно, чрез fromIntegral.
Това може да е малко досадно ако сте свикнали C++ да ви прави конвертиранията имплицитно, но се свиква.

Rational - рационални числа с пълна точност (представени като двойка числител и знаменател)

Char - знакове
     - връзка с ASCII кодовете им - ord :: Char -> Int, chr :: Int -> Char
     - toUpper, toLower, isUpper, isLower, isDigit
     
String - низ. Представен е като списък от Char-ове, но за това по-нататък

списъци и вектори (тук терминът се използва за наредени n-торки, не се бъркайте с std::vector-а) - на следващите упражнения -}

-- Задача 1. Да се дефинира функция myMin x y, която получава 2 цели числа и връща минималното от тях
-- 1ви вариант: ползвайки if
myМin :: Int -> Int -> Int
myМin x y = if x <= y then x else y
-- Тук then и else частите се задават със съответните ключови думи.
-- Няма нужда условието да се обгражда в скоби, но е задължително да имаме else част - не може само if then, като в C++

-- 2ри вариант: ползвайки "охраняващи изрази" (guards).
myМin' :: Int -> Int -> Int
myМin' x y
    | x <= y    = x
    | otherwise = y
-- Трябва guard-овете да са вложени на вътре, всички на едно и също ниво, като всеки започва с '|', има вида <условие> = <резултат>.
-- Подобно на cond в Racket - може да имаме произволен брой такива изрази, като условията се оценяват отгоре надолу, и ако някоe се оцени до True, се връща дясната страна.
-- Тук otherwise е еквивалента на else в cond-а (ключовата дума е различна, защото else вече е зает от if-а) - винаги се оценява до True, и обикновено го слагаме на последно място, 
-- защото ако има още случаи под него, до тях никога няма да се стигне.
-- Когато се налагат повече от две условия, ползваме guard-ове - недейте да влагате if-ове в if-ове

-- когато показвам допълнителни варианти на дадена функция, обикновено ще добавям ' към името им (като прим, секонд и т.н. в математиката, например f, f', f'', ...) 

-- Задача 2. Да се дефинира функция inside a b x, която проверява дали х е в интервала [a, b]
inside :: Int -> Int -> Int -> Bool
inside a b x = a <= x && x <= b

-- Задача 3. Да се дефинира функция average x y, която намира средно аритметичното на две цели числа
average :: Int -> Int -> Double
average x y = fromIntegral (x + y) / 2 -- трябва ни fromIntegral, тъй като (/) работи с числа с плаваща точка, а x + y ще е цяло число, тъй като x и y са цели

-- Задача 4. Да се дефинира функция sumSquares a b, която намира сумата на квадратите на числата a и b
sumSquares :: Int -> Int -> Int
sumSquares x y = x * x + y * y

-- втори вариант, с локална дефиниция на помощна функция
sumSquares' :: Int -> Int -> Int
sumSquares' x y = square x + square y
    where
        square :: Int -> Int -- в този случай бихме могли да пропуснем типовата декларация, тъй като square ще получи x или y, за които вече е ясно че са Int-ове
        square z = z * z
-- where определя локален блок. Всичко в един блок трябва да е вложено на едно и също ниво, така че при началото на нов блок, индентираме навътре 
-- (трябва да имаме поне един интервал, но ви съветвам да си ползвате tab-ове)

-- Всичко в един where блок е достъпно само в самия блок и във функцията, на която той принадлежи.
-- Така може да ползваме where блокове за да дефинираме локални променливи и функции, които няма да се ползват извън дадена функция.
-- За разлика от Racket, тук локалните дефиниции са след тялото от функцията,

{- в Хаскел индентацията е изключително важна - може би сте забелязали вече че нямаме ';' на края на редовете, но също така нямаме и ображдането със скоби от Racket.
Блокове тук се определят от индентацията - всичко в един блок е индентирано навътре (и то на едно и също ниво), а когато излезем от блока се връщаме към предишното ниво на индентация.

блок
    текст
    текст

блок
    текст
    текст
        блок
            текст
            текст 

Това може да доведе до доста грешки в началото докато свикнете. Ако се опитате да компилирате код и ви даде грешка която не сте очаквали, проверете си индентацията

Например, може просто да сте забравили да индентирате, или да имате разминаване в нивата на индентация:
блок
    текст
     текст
    текст
-}

-- Задача 5. Да се дефинира функция fib :: Int -> Integer, която намира n-тото число на Фибоначи
-- 1ви вариант - с guard-ове
fib :: Int -> Integer
fib n
    | n == 0 = 1
    | n == 1 = 1
    | otherwise = fib (n-1) + fib (n-2)

-- 2ри вариант: със съпоставяне с образец (pattern matching)
fib' :: Int -> Integer
fib' 0 = 1
fib' 1 = 1
fib' n = fib (n-1) + fib (n-2)
{- При pattern matching аргументите последователно се съпоставят с образците (левите страни на равенствата), т.е. от горе надолу.
При успешно съпоставяне се връша дясната страна на съответното равенство.
Образецът може да бъде: 
- литерал (число, буква, булева стойност, т.н.) - аргумент се съпоставя успешно ако е равен на стойността на литерала 
- променлива - аргумент винаги се съпоставя успешно с променлива
- '_' (wildcard - специален символ за безусловно съпоставяне) - винаги се съпоставя успешно. Ползваме го когато не ни интересува стойността на даден аргумент
- вектор (p1,p2,...,pn) - аргументът се съпоставя успешно, ако е от вида (v1,v2,...vn) и всяко vi се съпоставя със съответното pi
- конструктор - ще разберем какво е това по-нататък
-}

-- 3ти вариант: итеративно решение
fibIter :: Int -> Integer
fibIter n = helper 1 1 2
    where
        helper :: Int -> Integer -> Integer -> Integer
        helper i current next
            | i >= n    = current
            | otherwise = helper (i+1) next (current+next)

            
-- Ламбда функции - аналогично на тези в Racket, но тук ползваме символа '\' вместо lambda и '->' за да разделим променливите от тялото
lambda1 x = \ y -> x + y
lambda2 = \ x y -> x + y

-- Функции от по-висок ред - отново аналогични, но тъй като тук си декларираме типа на функциите ще трябва да го отбележим и там.
-- Когато имаме функция като аргумент или резултат, пишем нейната сигнатура и я обграждаме в скоби

-- Задача 6. Да се дефинира функция inside' :: Int -> Int -> (Int -> Bool), която получава само 2 аргумента - двата края на интервал.
-- inside' a b връща функция на 1 аргумент, която проверява дали той е в интервала [a,b]
inside' :: Int -> Int -> (Int -> Bool)
inside' a b = \ x -> a <= x && x <= b


-- Композиция на функции - ползваме символа '.' (точка, идеята е да символизира кръгчето, което ползваме в математиката)
-- Функциите се прилагат отдясно наляво
composedf x = (\ y -> y * y) . (\ y -> x + y)

-- Задача 7. Да се дефинира функция xSquaredPlusOne :: Int -> Int, която пресмята x^2 + 1, ползвайки композиция на функции
plusOne :: Int -> Int
plusOne x = x + 1
square :: Int -> Int
square x = x * x

xSquaredPlusOne :: Int  -> Int
xSquaredPlusOne x = (plusOne . square) x

-- Задача 8. Да се дефинира функция xPlusOneSquared :: Int -> Int, която пресмята (x+1)^2, ползвайки композиция на функции
xPlusOneSquared :: Int -> Int
xPlusOneSquared x = (square . plusOne) x

-- в Haskell, при композирането на функции често се ползва т. нар. pointfree нотация (https://wiki.haskell.org/Pointfree), или безаргументен стил.
-- Както се подсказва от второто име, тук изпускаме аргументите. Това прави дефинициите по-компактни, и спомага да мислим по-фокусирано за самото композиране на функции,
-- а не толкова за предаването на аргументи от една функция към друга.
xPlusOneSquared' :: Int -> Int
xPlusOneSquared' = square . plusOne
-- Една от основните техники е eta reduce. Идеята е, че ако даден аргумент го има в края на лявата и на дясната страна, може да го махнем. В този пример, такъв аргумент беше x.

-- Частично прилагане на функции - функция (на два или повече аргумента) може да бъде приложена само към част от аргументите си, като резултатът е функция на останалите аргументи.
-- Например ако имаме f :: Int -> Int -> Int -> Int и я приложим частично към първите 2 аргумента, резултатът ще е функция f' :: Int -> Int
p0 :: Int -> Int -> Int -> Int
p1 :: Int -> Int -> Int
p2 :: Int -> Int
p3 :: Int

p0 x y z = x + y + z
p1 y z   = p0 1 y z
p2 z     = p0 1 2 z
p3       = p0 1 2 3

-- По-детайлно за прилагането - в Haskell всъщност всяка функция е на един аргумент. Симулираме повече аргументи като връщаме функции.
-- Така f :: Int -> Int -> Int -> Int всъщност е f :: Int -> (Int -> (Int -> Int)), т.е. функция на 3 аргумента всъшност е функция на 1 аргумент, 
-- коятo връща функция на 1 аргумент, която от своя страна също връща функция на 1 аргумент, която вече извършва сметките и връща резултат.
-- При всяка от тези стъпки все едно фиксираме един аргумент.

-- Например в случая с p0 1 2 3 - p0 ще върне функция p1 :: Int -> (Int -> Int), като за нея x вече няма да е аргумент, а ще е фиксирано като 1.
-- Тя ще върне функция :: Int -> Int, за която y ще е фиксирано като 2, и която ще приеме един аргумент, откъдето ще разбере стойността на z.
-- След това вече всичките аргументи имат стойности и може да се извърши смятането на x + y + z = 1 + 2 + 3 = 6

-- Сечения на оператори - частично прилагане при оператори
plusOne' = (+1)
plusX x = (+x)

-- редът е от значение
lessThanFive = (<5)
greaterThanFive = (5<)
-- Общото правило гласи, че сечението на оператора op "добавя" аргумента си по начин, който завършва от синтактична гледна точка записа на приложението на оператора 
-- (обръщението към оператора).
-- в примерите: за да "завършим" <5 трябва да напишем нещо от лявата страна,  като така получаваме израза x < 5, а
--              за да "завършим" 5< трябва да напишем нещо от дясната страна, като така получаваме израза 5 < x, т.е. x > 5
divideByTwo = (/2)
divideTwoBy = (2/)


-- За разлика от Racket, тук вече не може да си пишем извиквания из кода - трябва това да става в отделно обособен main блок, подобно на C++.
-- Той може да е както най-отгоре, така и най-отдолу в програмата.
main :: IO()
main = do
    --print 3       -- -> 3
    --print (5 + 6) -- -> 11

    -- целочислено деление
    --print (div 18 7) -- -> 2
    -- остатък от целочислено деление
    --print (mod 18 7) -- -> 4

    -- в Haskell операциите са с инфиксен запис, а останалите функции са с префиксен, но може да преминаваме от единия към другия
    -- от инфиксен към префиксен - като оградим името на операцията в скоби
    --print ((+) 5 6)    -- -> 11
    -- от префиксен към инфиксен (само за функции с 2 аргумента) - като оградим името в обратни апострофи (backquotes)
    --print (18 `div` 7) -- -> 2
    --print (18 `mod` 7) -- -> 4

    -- степенуване на цели числа
    --print (11 ^ 2)   -- -> 121
    -- степенуване на реални числа
    --print (2 ** 0.5) -- -> 1.4142135623730951
 
    -- получаване на ASCII кода на символ
    --print (ord 'a') -- -> 97
    -- получаване на символ по даден ASCII код
    --print (chr 97)  -- -> 'а'

    -- закръгляне
    --print (floor 5.23)   -- -> 5
    --print (ceiling 5.23) -- -> 6
    --print (round 5.23)   -- -> 5
 
    
    --print a -- -> 5
    --print b -- -> 6
 
    --print (f1 1)     -- -> 2
    --print (f2 1)     -- -> 2
    --print (f3 1 2 3) -- -> 6


    --print (myМin 3 4)  -- -> 3
    --print (myМin' 3 4) -- -> 3
    
    --print (inside 1 5 3)   -- -> True
    --print (inside 1 5 0)   -- -> False
    --print (inside 1 5 1.5) -- error: No instance for (Fractional Int) arising from the literal `1.5'
 
    --print (average 3 4) -- -> 3.5

    --print (sumSquares 10 15)     -- -> 325
    --print (sumSquares' 10 15)    -- -> 325

    --print $ fib 6     --  -> 13
    --print $ fib' 6    --  -> 13
    --print $ fibIter 6 --  -> 13

    --print ((lambda1 3) 4) -- -> 7
    --print (lambda2 3 4)   -- -> 7
    
    --print ((inside' 3 5) 4) -- -> True
    --print (inside' 3 5 4) -- компилатора може да се оправи и без скоби - когато имаме функция, връщаща ламбда, може да си представим че просто 
    -- аргументите на ламбдата се прехвърлят към аргументите на самата функция


    {- $ e оператор, който прилага функция. Така може да си спестяваме скоби
    Например f (g x y) ще стане f $ g x y
    При един чифт скоби резултата не е особено различен, но при по-сложни функции се получават доста скоби
    Разбира се може да си пишете и със обикновени скоби, ако ви е по-удобно -}

    --print $ composedf 3 4 -- -> 49 (Първо прилагаме дясната функция, която връща 3 + 4 = 7. Лявата получава този резултат като аргумент и го повдига на квадрат)
    --print $ ((\ y -> y * y) . (\ y -> 3 + y)) 4 -- -> 49

    --print $ (plusOne . plusOne . plusOne) 5 -- -> 8
    --print $ xSquaredPlusOne 2 -- 5 (2^2 + 1 = 4 + 1)
    --print $ xPlusOneSquared 2 -- 9 ((2+1)^2 = 3^2)
    --print $ xPlusOneSquared' 2 -- 9 ((2+1)^2 = 3^2)
    

    --print $ p0 1 2 3 -- -> 6
    --print $ p1 2 3   -- -> 6
    --print $ p2 3     -- -> 6
    --print $ p3       -- -> 6
    
    --print $ plusOne' 5        -- -> 6
    --print $ (plusX 5) 4       -- -> 9
    --print $ lessThanFive 4    -- -> True
    --print $ lessThanFive 6    -- -> False
    --print $ greaterThanFive 4 -- -> False
    --print $ greaterThanFive 6 -- -> True
    --print $ divideByTwo 5     -- -> 2.5
    --print $ divideTwoBy 5     -- -> 0.4
