#lang racket
; коментар на един ред
#| коментар
на няколко
реда |#

; примитивни изрази
;100 ; -> 100
;"This is a string." ; -> "This is a string."
;+ ; -> #<procedure:+>

; префиксен запис на операции
;(+ 10 25) ; -> 35
;(- 10 25) ; -> -15
;(* 2 3) ; -> 6
; префиксният запис позволява прилагане на някои операции над повече от 2 аргумента
;(+ 1 2 3) ; -> 6
;(+ 1 2 3 4 5 6 7 8 9 10) ; -> 55

;(/ 10 3) ; -> 3 1/3
;(+ 1.5 2 3) ; -> 6.5
;(sqrt 16) ; -> 4
;(sqrt -16) ; -> 0+4i

; вложени изрази
;(+ (* 2 3) (- 5 4) (+ 1 2 3)) ; -> 13
;(+ (* 2 3 (+ 1 2 (- 4 3)))) ; -> 24 (2*3*4)

; булевите стойности в Racket са #t и #f, съответно за истина и лъжа
;(< 3 4) ; -> #t
;(> 3 4) ; -> #f

; равенстовто е само едно равно, а не ==-то от  С++
;(= 3 4) ; -> #f
; отрицание - с not
;(not (= 3 4)) ; -> #t

; логически оператори
;(and #t #f) ; -> #f
;(or #t #f)  ; -> #t
;(not #t)    ; -> #f

; тук булевите стойности са специален, нечислов тип. Не може да ги третираме като числа.
;(= #t 1) ; -> =: contract violation  expected: number?  given: #t

; дефиниране на променлива - задаваме име и стойност
(define x 5)
;x ; -> 5
;(+ x 2) ; -> 7
;(+ x x) ; -> 10

; ползваме термина "променлива", но дефакто това са константи - x не може да промени стойността си след като вече е дефинирано
;(define x 6) ; -> module: identifier already defined in: x

; дефиниране на функция - (define (<име> <аргумент 1> <аргумент 2> ... <аргумент n>) (<тяло>))
(define (f x) (+ x 1))
; израз трябва да бъде обграден в скоби за да бъде оценен. При липсата на скоби просто получаваме информация за името на процедурата
;f ; -> #<procedure:f>
;(f 1) ; -> 2
(define (g x y z) (+ x y z))


; Упражнение 1:
; Задача 1. Да се напише функция (square x), която връща квадрата на дадено число x.
(define (square x)(* x x))

;(square 5)    ; -> 25
;(square 2.25) ; -> 5.0625

; Задача 2. Да се дефинира фунцкия (myMin a b), която приема два аргумента и връща по-малкия от тях.
(define (myMin a b)
  (if (< a b)
      a
      b))
; if-а в Racket се оформа с обикновени кръгли скоби - (if (<условие>) <then-израз> <else-израз>). Няма нужда от ключова дума else - просто вторият израз е else-частта.
; тук изразите са просто по една стойност, но ако бяха по-сложни щяхме да ги обградим всеки в скоби

;(myMin 12.02 12.0001) ; -> 12.0001
;(myMin 4 2)           ; -> 2

; Задача 3. Да се дефинира функция (myMinSquare a b), коята приема два аргумента и връща квадрата на по-малкия от двата аргумента.
(define (myMinSquare a b)(square (myMin a b)))

;(myMinSquare 17 15)    ; -> 225
;(myMinSquare 12.3 6.5) ; -> 42.25

; Задача 4. Да се дефинира функция (sumCubes a b), която приема два аргумента a и b и връща сумата на техните кубове.
(define (cube x)(* x x x))
;(cube 5) ; -> 125

(define (sumCubes a b)
  (+ (cube a) (cube b)))

;(sumCubes 2 3) ; -> 35 (8 + 27)

; Задача 5. Да се дефинира функция (inside? x a b), която приема три аргумента - реално число x и границите a и b на реален интервал.
; Функцията да проверява дали числото принадлежи на интервала.

; прието е в Racket предикати (функции, които връщат булеви стойности) да се изписват с ? в края на името им
(define (inside? x a b)
  (and (<= a x) (<= x b)))

;(inside? 5.25 2 6)    ; -> #t
;(inside? 4 1.25 3.29) ; -> #f

; Задача 6. Да се дефинира функция (squaresAverage a b), която връща средно аритметичното от сумата на квадратите на a и b.
(define (squaresAverage a b)
  (/ (+ (square a) (square b)) 2))

;(squaresAverage 4 5) ; -> 20 1/2

; Задача 7. Да се дефинира функция (fact n), която пресмята n!.

; Математическата дефиниция на факториел:
;           { 1             , n = 0
; fact(n) = { 
;           { n * fact(n-1) , иначе

; Как бихме го написали в процедурен стил (примерно на С++):
; int fact(n) {
;     int result = 1;
;     for (int i = 1; i <= n; ++i)
;         result *= i;
;
;     return result;
; }

(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))
; директно преведохме математическата дефиниция - без цикли, без променлива в която да пазим резултата.

;(fact 1) ; -> 1
;(fact 2) ; -> 2
;(fact 3) ; -> 6
;(fact 5) ; -> 120
;(fact 10) ; -> 3628800
;(fact 40) ; -> 815915283247897734345611269596115894272000000000



; локални функции
(define (global-function x)
  (define (local-function y) (+ x y)) ; локалната функция "вижда" аргументите на глобалната, и може да ги ползва в своето тяло
  (local-function 5))

;(global-function 4)
;(local-function 5) ; -> local-function: unbound identifier - local-function е "видима" само за global-function, и следователно не може да се ползва извън тялото на global-function

; Задача 8. Да се дефинира функция (myGCD a b), която намира най-големия общ делител на числата a и b.
(define (myGCD a b)
  (define (helper a b) ; дефиниране на локална функция
    (if (= b 0)
        a
        (helper b (remainder a b))))
  (if (< a b)
      (helper b a)
      (helper a b)))

;(myGCD 15 5) ; -> 5
;(myGCD 5 15) ; -> 5
;(myGCD 13 6) ; -> 1
;(myGCD 6 13) ; -> 1

; Често при по-сложни задачи се налага да дефинираме локална функция, понякога повече от една.
; Когато не можем да измислим смислено име за локалната функция (или просто не ни се занимава), обикновено я кръщаваме просто "helper".

; Задача 9. Да се дефинира функция (myFib n), която получава един аргумент n и връща n-тото число от редицата на Фибоначи.
; Забележка: Редицата е 1, 1, 2, 3, .. и е индексирана от 0.
(define (myFib n)
  (if (or (= n 0) (= n 1))
      1
      (+ (myFib (- n 1)) (myFib (- n 2)))))

;(myFib 0) ; -> 1
;(myFib 1) ; -> 1
;(myFib 2) ; -> 2
;(myFib 3) ; -> 3
;(myFib 4) ; -> 5

; Горното решение е рекурсивно - поражда се верига от обръщения към функцията с "по-прости" аргументи (тук аргументите стават по-малки, но в други задачи промяната може да е различна), докато не се достигне базов случай.
; да проследим развитието на процеса:
;    (myFib 3)
; => (+ (myFib 2) (myFib 1))
; => (+ (+ (myFib 1) (myFib 0)) 1)
; => (+ (+ 1 1) 1)
; => (+ 2 1)
; -> 3
; имаме фаза на "разгъване" и фаза на "сгъване"

; Задача 10. Да се напише итеративно решение на Задача 7 (вижте Лекция 2 за детайлно описание на "итеративен процес").
(define (myFibIter n)
  (define (helper counter prev acc)
    (if (= counter n)
        acc
        (helper (+ counter 1) acc (+ acc prev))))
  (helper 0 0 1))

; prev е съкратено за previous - този аргумент съдържа предишното число на Фибоначи
; acc е съкратено за accumulated - наричаме този аргумент така, тъй като в него "акумулираме" резултата.
; Бихме могли да го кръстим и по-друг начин - current (или curr за по-кратко), тъй като съдържа текущото число на Фибоначи, или пък result (или res).

;(myFibIter 0) ; -> 1
;(myFibIter 1) ; -> 1
;(myFibIter 2) ; -> 2
;(myFibIter 3) ; -> 3
;(myFibIter 4) ; -> 5

; В итеративното решение, на всяка стъпка състоянието на изчисленията се описва от "променливи на състоянието" (state variables) и правило, с което може да се премине към следващата стъпка.
; Тук всъшност итеративната част е в helper, а не в главната функция - тя само извиква helper с подходящи аргументи

; да проследим развитието на процеса:
;    (myFibIter 4)
;            counter prev acc
; => (helper 0       0    1)
; => (helper 1       1    1)
; => (helper 2       1    2)
; => (helper 3       2    3)
; => (helper 4       3    5)
; -> 5

; Забележете, че в "итеративния" процес пак има рекурсия - дефиницията на итеративен във Функционалното програмиране не споменава липса на рекурсия.
; В тази парадигма нямаме средствата на императивните езици, така че почти всичко става с рекурсия.

; Защо са ни итеративните решения? Основната причина е ефективност.
; Може да проверим с time - вградена функция, която засича времето за изпълнение.

; примерни резултати от изпълнението
;(time (myFib 40))         ; -> cpu time: 12344 real time: 12737 gc time: 62
;(time (myFibIter 40))     ; -> cpu time: 0 real time: 1 gc time: 0
;(time (myFibIter 40000))  ; -> cpu time: 188 real time: 194 gc time: 125
;(time (myFibIter 400000)) ; -> cpu time: 8000 real time: 8243 gc time: 5531
; Може да се види колко по-бързо е итеративното решение. В случая на Фибоначи, директното рекурсивно решение е изключително бавно, тъй като на всяка стъпка правим по две рекурсивни извиквания.
; В други функции, като например факториел (при която има само едно рекурсивно извикване), рекурсивното решение няма да е толкова бавно, но пак ще е по-бавно от съответното итеративно.
