Упражнение 13 - Още задачи за дървета:

Задача 0. Миналият път видяхме как да представим аритметичен израз чрез двоично дърво и как да го отпечатаме. Как може да изчислим стойността му?
Задача 1. Нека имаме типът за цвят data Color = Red | Green | Blue deriving (Read, Show, Eq). Дефинирайте функция maxDepthBlueNode :: BTree Color -> Int, която намира дълбочината на най-дълбокия (най-отдалечения от корена) връх с цвят Blue на дадено двоично дърво от тип Color.
Примерно дърво:
colorTree :: BTree Color                                            --            Blue
colorTree = Node Blue (Node Red (Node Green Empty Empty) Empty)     --           /    \
                      (Node Red (Node Blue (Node Green Empty Empty) --        Red      Red
                                           (Node Red Empty Empty))  --        /        /  
                                Empty)                              --     Green     Blue  
                                                                    --               /   \
                                                                    --            Green  Red
Задача 2. Дефинирайте функция maxDepthNode :: BTree Color -> Color -> Int, която намира дълбочината на най-дълбокия връх с цвят, подаден като аргумент, на дадено двоично дърво от тип Color. 

Задача 3. Да се дефинира алгебричен тип NTree а, който да представлява дърво с произволен брой наследника на всеки възел. За него да се дефинира фунцкия size, която брои елементите му
Примерно дърво:
nTree1 :: NTree Int                               --       1
nTree1 = NNode 1 [(NNode 2 [(NNode 3 [NEmpty]),   --      / \
                            (NNode 4 [NEmpty]),   --     2   6
                            (NNode 5 [NEmpty])]), --    /|\  |
                  (NNode 6 [(NNode 7 [NEmpty])])] --   3 4 5 7
Задача 4. Казваме, че едно дърво е грациозно, ако абсолютните стойности на разликите между стойностите на всеки елемент и бащиния му са четни. Да се дефинира функция isGraceful :: NTree Int -> Bool, която приема n-арно дърво и проверява дали то е грациозно.


Друго представяне на дървета с произволен брой наследници: Асоциативен списък [(а, [а])], където a е типът на върховете на дървото.
Примерни дървета:
t1 = [(4, [2, 5]), (2, [1, 3])]
    4
   / \
  2   5
 / \
1   3
t2 = [(1,[2,3,4]),(2,[5,6]),(3,[7]),(4,[8,9]),(5,[]),(6,[10]),(7,[]),(8,[]),(9,[]),(10,[])]
       1 
  2    3    4
 5 6   7   8 9
    10

Задача 5. Да се дефинира функция twoChildrenNodes, която намира броя на върховете в дърво, които имат точно два наследника. 
Задача 6. Да се дефинира функция allHaveTwoChildren, която проверява дали всички върхове (които не са листа) в дървото имат точно по два наследника.
Задача 7. Дефинирайте функция findUncles, която за дадени дърво tree и връх node на tree намира списък от всички чичовци на node в tree.

Обратно към двоични дървета.
Задача 8. Казваме, че едно двоично дърво е огледално-симетрично, ако лявото му поддърво е огледален образ на дясното. Да се дефинира предикат isSymmetric :: BTree Int -> Bool, който проверява дали дадено двоично дърво е огледално-симетрично.

Задача 9. Да се дефинира функция containsWord :: BTree Char -> String -> Bool, която по дадено двоично дърво от символи и дума, съставена от поне една буква, проверява дали думата се среща в дървото, като последният символ от думата е лист в това дърво.
Задача 10. Да се дефинира функция genWords :: BTree Char -> [String], която по дадено двоично дърво от символи връща списък от всички думи, съдържащи се в него.
Задача 11. Да се дефинира функция allContain :: [BTree Char] -> [String], която по даден списък от двоични дървета от символи връща списък от тези думи, които се съдържат във всички дървета.
Примерно дърво:
charTree1 :: BTree Char                                --     a
charTree1 = Node 'a' (Node 'c' (Node 'f' Empty Empty)  --    / \
                               (Node 'd' Empty Empty)) --   c   b
                     (Node 'b' Empty                   --  / \   \
                               (Node 'e' Empty Empty)) -- f   d   e
