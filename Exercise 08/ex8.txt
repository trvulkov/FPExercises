Следващия път почваме с Haskell. Може да се подготвите предварително за другата сряда, за да може директно да почнете да пишете код.
Първо ще трябва да си setup-нете Haskell - https://cabal.readthedocs.io/en/latest/getting-started.html   https://www.fpcomplete.com/haskell/get-started/	https://www.haskell.org/platform/

За Haskell няма някакво специфично IDE, ще ползваме Code Editor с плъгини. Аз лично ще ползвам VS Code, но може да ползвате какъвто и да е редактор с подходящи плъгини. 
Може да разгледате тук: https://wiki.haskell.org/IDEs
За VS Code ви трябват плъгините Code Runner и Haskelly

От миналия път:
Задача 11. "Дълбок списък" ще наричаме списък, който може да съдържа други списъци, а "атом" - елемент на дълбок списък, който не е списък (примерно число или символ). "Ниво на влагане" на атом в дълбок списък наричаме броя пъти, който трябва да се приложи операцията car за достигане до атома. Да се реализира функция deep-delete, която в даден дълбок списък (в който всеки атом е число) изтрива всички атоми, които са по-малки от нивото им на влагане.
Пример: (deep-delete `(1 (2 (2 4) 1) 0 (3 (1)))) ; -> (1 (2 (4)) (3 ())))

Упражнение 8:
Задача 1. Да се дефинира функция (diagonal mat), която получава квадратна числова матрица mat, представена като списък от списъци, и връща списък от елементите на главния диагонал на матрицата.
Пример:
(define matrix `((1 2 3 4)
                 (5 6 7 8)
                 (9 10 11 12)
                 (13 14 15 16)))

(diagonal matrix) ; -> (1 6 11 16)

Задача 2. Да се дефинира функция от по-висок ред (tabulate f), която връща като резултат функция. Върнатата функция приема като аргументи целите числа a и b и връща като резултат списък от точкови двойки от вида '(x . fx), първите елементи на които са поредните точки от интервала [a, b], а вторите – стойностите на f в тези точки. 
Пример: ((tabulate sqr) 1 5) ; -> '((1 . 1) (2 . 4) (3 . 9) (4 . 16) (5 . 25))

Задача 3. Да се дефинира функцията (latin-square? xss), която проверява дали матрицата xss е латински квадрат (определение на понятието можете да намерите например на https://en.wikipedia.org/wiki/Latin_square). 
Можете да приемете, че за символи ще използваме числата от 1 до n, където n е големината (броят на редовете/стълбовете) на матрицата.
Пример:
(define latin '((1 2 3 4)
                (4 3 2 1)
                (2 4 1 3)
                (3 1 4 2)))

(latin-square? latin) ; -> #t

Задача 4. Да се дефинира функция (pair-compose fs), която получава списък (f1 f2 f3 ... fn) от едноаргументни числови функции и връща нова едноаргументна числова функция g - такава, че оценката на (g x) е равна на сумата (f1.f2)(x) + (f3.f4)(x) + ... + (fn-1.fn)(x), където "." означава композиция на функции. Ако оригиналният списък с функции има нечетен брой елементи, то последната функция от списъка се композира с функцията идентитет, която получава един аргумент и го връща без промяна.
Пример:
(define function-list (list sqr
                            (λ (x) (* x x x))
                            (λ (x) (+ x 1))
                            (λ (x) (- x 1))
                            (λ (x) (+ x 2))))

((pair-compose function-list) 4) ; -> 4106 == (4^3)^2 + (4+1-1) + (4+2).id == 4096 + 4 + 6

Задача 5. Нека l1 = (a1 a2 ... ak) и l2 = (b1 b2 ... bk) са непразни списъци с еднакъв брой числа. Да се дефинира предикат (image? l1 l2), който да връща „истина“ точно когато съществува такова число x, че ai = x + bi за всяко i = 1,..., k.
Примери:
(image? '(1 2 3) '(4 5 6)) ; -> #t
(image? '(1 2 3) '(1 2 2)) ; -> #f
(image? '(5 6 7) '(1 2 3)) ; -> #t

Задача 6. Да се дефинира функция (closest-point xys), която приема списък xys от точки в равнината (представени чрез двойки (x.y)) и връща едноаргументна функция, чиято стойност в дадена точка p e най-близката до p точка от списъка xys.
Примери:
((closest-point '((1 . 2) (1.2 . 1.3) (3 . 4) (7 . 10))) '(7.1 . 10))  ; -> '(7 . 10)
((closest-point '((1 . 2) (1.2 . 1.3) (3 . 4) (7 . 10))) '(1 . 2.1))   ; -> '(1 . 2)
((closest-point '((1 . 2) (1.2 . 1.3) (3 . 4) (7 . 10))) '(1.2 . 1.3)) ; -> '(1.2 . 1.3)

Задача 7. В лингвистиката т. нар. разстояние на Левенщайн между две думи a и b се дефинира като минималния брой букви, които трябва да бъдат заменени, вмъкнати или изтрити, за да се преобразува a в b.
https://en.wikipedia.org/wiki/Levenshtein_distance#Definition
Да се дефинира функция (naive-levenshtein word1 word2), която намира разстоянието на Левенщайн между две дадени думи, представени като списъци от съставящите ги букви.
Примери:
(naive-levenshtein `(c a t) `(h a t))               ; -> 1
(naive-levenshtein `(c a t) `(d o g))               ; -> 3
(naive-levenshtein `(k i t t e n) `(w r i t t e n)) ; -> 2
(naive-levenshtein `(k i t t e n) `(s i t t i n g)) ; -> 3

Задача 8. Ако са дадени два списъка от цели числа xs и ys, да се дефинира функция на (contains-multiple-of-all? xs ys), която проверява дали съществува такъв елемент на xs, който е кратен на всички елементи на ys.
Примери:
(contains-multiple-of-all? `(3 4 16) `(2 4 8)) ; -> #t (16 е кратно на 2, 4 и 8)
(contains-multiple-of-all? `(3 4) `(2 4 8))    ; -> #f (3 не е кратно на нито едно от ys, 4 е кратно на 2 и 4, но не на 8)

Задача 9. Да се дефинира функция (find-max f a b), която по дадена двуаргументна числова функция f и цели числа a и b намира интервалът (i, j), a ≤ i < j ≤ b, за който стойността f(i, f(i+1, ... f(j-1, j))) е най-голяма.
Примери:
(find-max - 1 5) ; -> '(3 . 5)
(find-max + 1 5) ; -> '(1 . 5)
(find-max * 1 5) ; -> '(1 . 5)
(find-max / 1 5) ; -> '(3 . 5)
