Теория: Генерични и полиморфни функции
Теория: Класове

Теория: Алгебрични типове
Задача 1. Да се дефинира типа Shape с 4 конструктора: 
	Circle,    който има 1 аргумент  - радиус
	Rectangle, който има 2 аргумента - ширина и височина
	Triangle,  който има 3 аргумента - 3 страни
	Cylinder,  който има 2 аргумента - радиус на основата и височина
Типа Shape да се направи екземпляр на класа Show и за него да се дефинира метода show, позволяващ print-ването му
Задача 2. За Shape да се дефинират:
	a) функция perimeter :: Shape -> Double, която намира периметъра на фигурата
	b) функция area :: Shape -> Double, която намира лицето на фигурата
	c) предикат isRound :: Shape -> Bool, който проверява дали дадена фигура е кръгла (някоя от стените е окръжност)
	d) предикат is2D :: Shape -> Bool, който проверява дали дадена фигура е равнинна (лежи в една равнина)
Задача 3. Да се дефинира функция sumArea, която приема списък от фигури и връща сумата от лицата на фигурите в списъка. Да се дефинира още една функция biggestShape, която намира фигурата с най-голямо лице.

Задача 4. Да се дефинира тип Point, който задава точка в равнината и точка в пространството. Типа да се направи екземпляр на класа Eq и за него да се дефинира равенство на точки от една и съща размерност.
Задача 5. Да се дефинира функция distance за работа с типа Point, която намира разстоянието между две (съвместими) точки. Ако точките са с различна размерност (т.е. имат различен брой координати) функцията да връща съобщение за грешка.
Задача 6. Да се дефинира функция getClosestPoint, която приема списък от точки и още една точка p. Като резултат функцията да връща тази точка от списъка, която е най-близо до точката p.

Теория: Рекурсивни алгебрични типове
Задача 7. Да се дефинира рекурсивен алгебричен тип двоично дърво, който има стойности от тип Int по върховете си. Нека типът е екземпляр на класа Show.
Задача 8. Да се преработи алгебричния тип за двоично дърво, така че при конструирането му да може да се определя типа на възлите. За двоичното дърво да се дефинират следните функции:
	a) size, която намира броя на възлите на двоично дърво
	b) height, която намира височината на двоично дърво
	c) sumTree, която намира сумата от възлите на двоично дърво. Забележка: функцията трябва да работи само за такива дървета, чиито възли наистина могат да се сумират! (например за BTree Char няма да могат)
	d) sumLeaves, която намира сумата на елементите по листата на двоично дърво
	e) inorder, която обхожда двоично дърво в ред Ляво-Корен-Дясно
	f) равенство на дървета (чрез операцията (==)). Забележка: за да може да сравняваме дървета за равенство, трябва първо да можем да сравняваме стойностите във възлите им!
Задача 9. Да се дефинира функция average :: BTree Int -> Double, която приема двоично дърво от цели числа и пресмята средно-аритметичното от записаното във върховете му.
Задача 10. Да се дефинира функция getLevel :: Int -> BTree a -> [a], която приема цяло число k и двоично дърво t и връща списък от елементите на k-то ниво на t.

Задача 11. Да се дефинира функцията getLevelsTree, която приема двоично дърво от произволен тип и заменя всеки негов възел с двойка от стойността на възела и номера на нивото му.
Например:
    1             (1,0)
   / \             / \
  2   3   =>   (2,1) (3,1)
 /   / \       /     /  \
5   7   6    (5,2) (7,2) (6,2)
Задача 12. Да се дефинира функция mirrorTree :: BTree a -> BTree a, която преобразува двоично дърво в "огледалното" му.
Например:
    1           1    
   / \         / \
  2   3   =>  3   2
 /   / \     / \   \
5   7   6   6   7   5
Задача 13. Да се дефинира функция mapTree, която приема функция f и двоично дърво t и прилага f към всеки възел на t.
