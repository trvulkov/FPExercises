#lang racket
; Упражнение 4:
; Функции от по-висок ред, Ламбда функции

; Функции от по-висок ред - функции, които манипулират други функции (получават функция като аргумент или връщат функция като резултат)
; Пример. Функция, която по подадени числа a и b и едноаргументна функция f, намира f(a) + f(a+1) + ... + f(b)
(define (sum a b f)
  (if (> a b)
      0
      (+ (f a) (sum (+ a 1) b f))))

(define (increment x) (+ x 1))
(define (square x) (* x x))

;(sum 1 3 increment) ; -> 9  (2 + 3 + 4)
;(sum 1 3 square)    ; -> 14 (1 + 4 + 9)

; За да тестваме функцията sum дефинирахме нови функции, които да подадем като аргументи. Но това са много кратки и елементарни функции, които най-вероятно ще ползваме само тук.
; Обособяването им като отделни функции с имена може да е излишно, и за да го избегнем ще ползваме така наречените "анонимни" (безименни) функции. Дефинират се чрез ключовата дума lambda:
;(lambda (x) (+ x 1)) ; -> #<procedure:...ения/ex4.rkt:21:0>
; Тук не сме подали аргумент, и съответно изразът се оценява до процедура, а не конкретна стойност
; Тъй като функцията е анонимна, ние всъщност няма как да я извикаме след дефинирането ѝ.

; може да ползваме и гръцката буква λ - в DrRacket е 'Ctrl' + '\'
;(λ (x) (+ x 1))

; Извикването с аргументи става така - ((lambda (arg1 arg2 ... argN) <тяло>) value1 value2 ... valueN)
;((λ (x) (+ x 1)) 2)           ; -> 3 (2 + 1)
;((λ (x y z) (+ x y z)) 1 2 3) ; -> 6

; На практика ламбдите не се ползват като в горните примери - обикновено се подават като аргументи на други функции, или се връщат като резултат.
;(sum 1 3 (λ (x) (+ x 1))) ; -> 9  (2 + 3 + 4)
;(sum 1 3 (λ (x) (+ x 5))) ; -> 21 (6 + 7 + 8)

;(sum 1 3 (λ (x) (* x x))) ; -> 14 (1 + 4 + 9)

;(sum 1 3 (λ (x) (* x 2))) ; -> 12 (2 + 4 + 6)
;(sum 1 3 (λ (x) (* x 3))) ; -> 18 (3 + 6 + 9)

; Това бяха примери за приемане на ламбда като аргумент - да видим и един за връшане.
; Ще дефинираме едноаргументна функция, която връща друга едноаргументна функция, добавяща своя аргумент към този на първата (леко извъртяно, но е само за пример).
(define (addY x) (λ (y) (+ x y)))

;(addY 5) ; -> #<procedure:...ения/ex4.rkt:42:17>
; addY не връша конкретна стойност, а функция - това е функция, която ще добавя 5 към аргумента си

;((addY 5) 4) ; -> 9 (5 + 4)
; чак когато подадем аргумент на върнатата функция може да получим резултат

; може да именуваме върната функция
(define addFive (addY 5)) ; тук в дефиницията не слагаме аргумент, тъй като вече го има от дефиницията на addY
; (define addFive (addY 5)) е еквивалентно на (define addFive (λ (y) (+ 5 y)), което пък е еквивалентно на (define (addFive y) (+ 5 y))
;(addFive 4) ; -> 9

; Трябва да внимаваме с аргументите
(define (add x y) (λ (a b) (+ a b))) ; Какво връща тази функция?
;((add 3 4) 13 14) ; -> 27 (13 + 14)
; Тук 3 и 4 ги игнорираме тотално - те се подават като аргументи, но в тялото не се ползват те, а a и b, които се подават на ламбдата.

; Задача 1. Да се дефинират следните функции:
; а) (myNegate predicate?) - отрицание на предикат 
(define (myNegate predicate?)
  (λ (x) (not (predicate? x))))

;((λ (x) (> x 10)) 5)             ; -> #f
;((myNegate (λ (x) (> x 10))) 5) ; -> #t

; Може да именуваме горния предикат
(define greaterThanTen? (λ (x) (> x 10)))

;(greaterThanTen? 5)            ; -> #f
;((myNegate greaterThanTen?) 5) ; -> #t

; b) (twice f) - прилага функцията f два пъти
(define (twice f)
  (λ (x) (f (f x))))

;(twice (λ (x) (+ x 1)))     ; -> #<procedure:...ения/ex4.rkt:77:2>
;((twice (λ (x) (+ x 1))) 3) ; -> 5 ((3 + 1) + 1)

; c) (myCompose f g) - композиция
(define (addOne x) (+ x 1))
(define (multByTwo x) (* x 2))

(define (myCompose f g)
  (λ (x) (f (g x))))

;(myCompose addOne multByTwo)     ; -> #<procedure:...ения/ex4.rkt:80:2>
;((myCompose addOne multByTwo) 3) ; -> 7 ((3 * 2) + 1 = 6 + 1 - композираните функции се изпълняват от дясно на ляво) 
;((myCompose multByTwo addOne) 3) ; -> 8 ((3 + 1) * 2 = 4 * 2)

;(myCompose (λ (x) (+ x 5)) (λ (x) (* x 4)))     ; -> #<procedure:...ения/ex4.rkt:80:2>
;((myCompose (λ (x) (+ x 5)) (λ (x) (* x 4))) 3) ; -> 17 (3 * 4) + 5 = 12 + 5
;((myCompose (λ (x) (* x 4)) (λ (x) (+ x 5))) 3) ; -> 32 (3 + 5) * 4 = 8 * 4

; може и миналата функция да дефинираме чрез тази
(define (twiceWithCompose f) (myCompose f f))
;((twiceWithCompose addOne) 3) ; -> 5

; d) (myRepeat f n) - прилагане на f n пъти (n-кратна композиция)
; рекурсивно:
(define (myRepeat f n)
  (if (<= n 0)
      identity ; вградена функция идентитет - връша това, което ѝ е подадено, без никакви промени
      (myCompose f (myRepeat f (- n 1)))))

;(myRepeat addOne 3)     ; -> #<procedure:...ения/ex4.rkt:87:2>
;((myRepeat addOne 3) 1) ; -> 4 (((1 + 1) + 1) + 1)

; итеративно: на k-та стъпка аргументът acc представлява k-кратната композиция на f
(define (myRepeatIter f n)
  (define (helper counter acc)
    (if (> counter n)
        acc
        (helper (+ counter 1) (compose f acc)))) ; тук вместо нашето myCompose ползваме вградената функция за композиция
  (helper 1 identity))

;(myRepeatIter addOne 3) ; -> #<procedure:composed>
; (тъй като ползвахме вградената функция за композиция, така че резултатът е малко по-различен - в горните примерни това което е заместено от многоточие
; е пътят до файла на моя компютър, но при вградената функция получаваме директно името)
;((myRepeatIter addOne 3) 1)  ; -> 4


; Задача 2. Да се дефинира функция от по-висок ред (deriveN f n eps), която намира n-та производна (по-точно - приближение на производна) на едноаргументната реална функция f с точност eps.

; първо да сметнем първа производна (по-точно - приближение на първа производна)
(define (derivative f eps)
  (λ (x) (/ (- (f (+ x eps))
               (f x))
            eps)))
; когато имаме по-дълги и сложни изрази, понякога разделяме аргументите на отделни редове - автоформатирането на DrRacket би трябвало да ги подравни
; без новите редове щеше да изглежда така: (/ (- (f (+ x eps)) (f x)) eps)))

; примерна функция
(define (f x) (* 2 x x x))

;(f 2) ; -> 16 (2 * 2^3 = 2 * 8)

; 1e-3 е scientific notation за 1 * 10^(-3) = 0.001
;((derivative f 1e-3) 2) ; -> 24.0120019999992
;((derivative f 1e-6) 2) ; -> 24.000012004421478
; f(x) = 2*(x^3) => f'(x) = 6*(x^2) => f'(2) = 6*4 = 24, но ние търсим приближение, а не точната стойност
; при различни eps ще получаваме различни резултати, но не е задължително при намаляване на eps винаги да получаваме по-голяма точност - зависи от спецификите на функцията.
; При прекалено малко eps даже получаваме 0, което е напълно грешно.

(define (deriveN f n eps)
  (if (<= n 0)
      f
      (deriveN (derivative f eps) (- n 1) eps)))

; f'(x) = 6*(x^2) => f''(x) = 12*x => f''(2) = 24
;((deriveN f 2 1e-6) 2) ; -> 23.998580900297384
; f''(x) = 12*x   => f'''(x) = 12  => f'''(2) = 12
;((deriveN f 3 1e-3) 2) ; -> 12.000015203739167


; Частично прилагане (currying) на функции - прилагане на функция към само част от аргументите ѝ. Резултатът е нова функция с по-малък брой аргументи - все едно сме фиксирали първите няколко.
(define (myCurry f x)
  (λ (y) (f x y)))

(define twoToThePowerOf (myCurry expt 2)) ; в израза (expt x y) все едно фиксираме x да е 2, т.е. получаваме (expt 2 y), или 2^y
;(twoToThePowerOf 4) ; -> 16
;(twoToThePowerOf 8) ; -> 256

; нашата реализация работи само за функции на 2 аргумента, но вградената в езика функция curry работи за произволен брой аргументи
(define (f1 x y z) (+ x y z))

(define f2 (curry f1 5))
;(f2 3 4) ; -> (f1 5 3 4) -> 12
;(f2 1 2) ; -> (f1 5 1 2) -> 8

(define f3 (curry f1 5 3))
;(f3 4)   ; -> (f1 5 3 4) -> 12

(define f4 (curry f1 5 3 4))
;f4 ; f4 вече не е процедура, а просто стойността на (f1 5 3 4) -> 12

;(define f5 (curry f1 5 3 4 6))
; -> arity mismatch - f1 има само 3 аргумента

; На Haskell частичното прилагане като цяло е по-удобно. Там ще видим повече и по-полезни примери, и ще го ползваме на практика.



; Пример за letrec/let*
; Задача 3. Да се дефинира функция (orderedBy pred? x), която проверява дали цифрите на числото x са подредени според предиката pred?.
; (като обобщение на increasingDigits? от миналия път - според предиката може да проверяваме за нарастващ или намаляващ ред (и потенциално някакви други, нестандартни подредби))
(define (orderedBy pred? x) ; pred? е двуместен предикат
  (letrec ; с обикновения let ще даде грешка при secondToLast - butLast: unbound identifier in: butLast
      ([butLast      (quotient x 10)]         ; всички цифри на числото без последната
       [last         (remainder x 10)]        ; последна цифра
       [secondToLast (remainder butLast 10)]) ; hover върху butLast ще покаже откъде се взима оценката
    (cond [(< x 10)                  #t]
          [(pred? secondToLast last) (orderedBy pred? butLast)]
          [else                      #f])))

;(orderedBy < 1234) ; -> #t
;(orderedBy < 4321) ; -> #f
;(orderedBy > 4321) ; -> #t
;(orderedBy > 1231) ; -> #f
;(orderedBy < 1231) ; -> #f
;(orderedBy (λ (x y) (= x (+ y 2))) 86420) ; -> #t

; Задача 4. Да се дефинира функция (perfectNumber? n), която проверява дали числото n e съвършено, т.е. дали е равно на сбора на делителите си.
(define (perfectNumber? n)
  (define (sumDivisors current sum)
    (cond [(= current n)               sum]
          [(= (remainder n current) 0) (sumDivisors (+ current 1) (+ sum current))]
          [else                        (sumDivisors (+ current 1) sum)]))
  (= (sumDivisors 1 0) n))

;(perfectNumber? 1)  ; -> #f ; 1 ≠ 0
;(perfectNumber? 14) ; -> #f ; 1 + 2 + 7 ≠ 14
;(perfectNumber? 6)  ; -> #t ; 1 + 2 + 3 = 6
;(perfectNumber? 28) ; -> #t ; 1 + 2 + 4 + 7 + 14 = 28

; Задача 5. Да се дефинира функция (newton-sqrt x), която пресмята корен квадратен по метода на Нютон с итеративно подобряване на приближението:
; https://en.wikipedia.org/wiki/Newton%27s_method#Square_root

; а) със смятане до n-та стъпка
(define (newtonSqrt x n)
  (define (f y) (- (* y y) x))
  (define (helper i xi)
    (if (> i n)
        xi
        (helper (+ i 1) (- xi (/ (f xi)
                                 ((derivative f 1e-6) xi))))))
  (helper 0 x))

;(newtonSqrt 36 0) -> 18.500000176874487
;(newtonSqrt 36 1) -> 10.22297328269325
;(newtonSqrt 36 6) -> 6.0
;(newtonSqrt 36 7) -> 6.0

; b) с проверка на грешката
(define (newtonSqrtAlt x)
  (define (helper x guess)
    ;(define error (abs (- (* guess guess) x)))
    ;(define next (average guess (/ x guess)))
    (let ([error (abs (- (* guess guess) x))] ; локалните дефиниции на error и next могат да се внесат в let
          [next (/ (+ guess (/ x guess)) 2)])
      (if (< error 0.001) ; с намаляване на второто число ще се получава по-точен резултат
          guess
          (helper x next))))
  (helper x 1.0))

; c) с проверка на грешката и показване на броя итерации
(define (newtonSqrtFinal x)
  (define (helper x guess iterations)
    (let ([error (abs (- (* guess guess) x))]
          [next (/ (+ guess (/ x guess)) 2)])
      (if (< error 0.001)
          (cons guess iterations) ; cons конструира нещо наречено "точкова двойка" - ще говорим в детайли следващия път когато започнем списъци, засега може да мислите за наредена двойка (guess, iterations)
          (helper x next (+ iterations 1)))))
  (helper x 1.0 0))

;(newtonSqrtAlt 5)       ; -> 2.2360688956433634
;(newtonSqrtFinal 5)     ; -> '(2.2360688956433634 . 4)
;(newtonSqrtFinal 36)    ; -> '(6.000000005333189 . 6)
;(newtonSqrtFinal 10000) ; -> '(100.00000025490743 . 10)