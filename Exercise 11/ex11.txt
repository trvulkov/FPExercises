Упражнение 11: Вектори/n-торки (tuples) - наредени n-торки от елементи.

Теория: n-торки, дефиниране на типове
Задача 0. Да се дефинира функция isAscending :: Integer -> Bool, която проверява дали цифрите на число са във възходящ ред. Функцията да получава число, но да работи със списък от цифрите му.
Задача 1. Да се дефинира функция numBiggerElements :: [Int] -> [(Int, Int)], която за даден списък от числа xs връща като резултат списък с елементи от вида (xi, ni), където xi е i-тият елемент на xs, а ni е броят на елементите на xs, които са по-големи от xi.
Задача 2. Да се дефинира функция splitByParity :: [Int] -> ([Int], [Int]), която получава списък от цели числа и го разделя на два списъка - от нечетни и четни.
Задача 3. Да се дефинира функция partition' :: (a -> Bool) -> [a] -> ([a], [a]), която получава предикат и списък и разделя списъка на 2 части:
	1) елементите, които удовлетворяват предиката
	2) елементите, които не го удовлетворяват
Функцията е с ', тъй като вече съществува вградена функция под името partition.
Да се пререши splitByParity, ползвайки partition.
Задача 4. Да се дефинира функция quickSort :: [Int] -> [Int], която реализира бързо сортиране върху списък.

Задача 5. Да се дефинира тип Vector, определящ се от три координати - x, y и z. Да се дефинират функции за работа с типа:
	а) sumVectors :: Vector -> Vector -> Vector, която намира сумата на два вектора
	b) scaleVector :: Vector -> Double -> Vector, която умножава скалар и вектор
	c) dotProduct :: Vector -> Vector -> Double, която намира скаларното произведение на два вектора

Задача 6. Да се дефинира тип Product, определящ се от име, количество и цена. Да се дефинира тип Shop (“база от данни”), който представлява инвентара от продукти на даден магазин.
Задача 7. Да се дефинира функция getPrice :: Product -> Float, която връща цената на даден продукт.
Задача 8. Да се дефинира функция getTotal :: Shop -> Float, която връща оборота на даден магазин, ако е продаден целият инвентар.
Задача 9. Да се дефинира функция buy :: String -> Int -> Shop -> Shop, която симулира “закупуването” на даден продукт, като приема име, количество и магазин. Да се вземе предвид, че не може след продажбата в магазина да имаме отрицателно количество за даден продукт. Ако искаме да купим продукт, но неговата наличност е недостатъчна, нека операцията да е празна, т.е. да не променя нищо. Ако след покупка количеството е станало 0, продуктът да се премахне от инвентара.
Задача 10. Да се дефинира функция getNeeded :: Int -> Shop -> [Product], която връща списък от продукти, чиято наличност е по-малка или равна на даден праг (количество).
Задача 11. Да се дефинира функция closestToAverage :: Shop -> String, която намира името на продукта, чиято цена е най-близка до средната за всички в даден магазин.
Задача 12. Да се дефинира функция cheaperAlternative, която намира броя на продуктите, за които има продукт със същото име, но по-ниска цена.

Примерни магазини:
[("Milk",5,1.2), ("Cheese",20,1.8), ("Bread",10,0.5), ("Chocolate",3,2.0)]
[("bread", 1, 1), ("milk", 1, 2.5), ("lamb", 1, 10), ("cheese", 1, 5), ("butter", 1, 2.3)]
[("bread", 1, 1), ("cheese", 1, 2.5), ("bread", 1, 1), ("cheese", 1, 5), ("butter", 1, 2.3)]

Задача 13. Да се дефинира функция calcFrequencyTable :: String -> [(Char,Int)], която получава низ cs, състоящ се от символите a-z. Функцията трябва да върне списък от двойки, в които първият елемент е символ от cs, а вторият е броя на срещания на този символ. В резултатът трябва да присъстват всички символи на cs, без повторение. Двойките трябва да са сортирани в низходящ ред по броя на срещанията, като при еднакъв броя срещания първа трябва да е двойката със символ с по-малък ASCII код.
Пример: calcFrequencyTable "aaabbbc" -> [('a',3),('b',3),('c',1)]
