#lang racket
; Коментари - в качените решения има разни поясняващи коментари. Поглеждайте си ги вкъщи, в случай че аз забравя да ги спомена на място.
; По този повод - неща които забравих миналия път:
; - вложени изрази - внимаваме със скобите и префиксния запис
;(+ (* 2 3) (- 5 4) (+ 1 2 3)) ; -> 13
;(+ (* 2 3 (+ 1 2 (- 4 3)))) ; -> 24 (2*3*4)

; - защо "inside?" беше кръстена така? Просто в Racket е прието предикати (функции, които връщат булеви стойности) да се изписват с ? в края на името им.

; - защо в последните задачи кръстихме локалните функции "helper"? Когато не можем да измислим смислено име за локалната функция (или просто не ни се занимава),
; обикновено ползваме това име - тези функции са точно "помощници" на главните функции.


; да преговорим някои неща от миналия път

; префиксен запис на операции
;(10 + 25) ; application: not a procedure;
;(+ 10 25) ; -> 35

; дефиниране на функция - (define (<име> <аргумент 1> <аргумент 2> ... <аргумент n>) (<тяло>))
(define (f x) (+ x 1))
; израз трябва да бъде обграден в скоби за да бъде оценен. При липсата на скоби просто получаваме информация за името на процедурата
;f ; -> #<procedure:f>
;+ ; -> #<procedure:+>
;(f 1) ; -> 2

; локални функции
(define (global-function x)
  (define (local-function y) (+ x y)) ; локалната функция "вижда" аргументите на глобалната, и може да ги ползва в своето тяло
  (local-function 5))

;(global-function 4)
;(local-function 5) ; -> local-function: unbound identifier - local-function е "видима" само за global-function, и следователно не може да се ползва извън тялото на global-function


; Фибоначи

; Рекурсивно решение - поражда се верига от обръщения към функцията с "по-прости" аргументи (тук аргументите стават по-малки, но в други задачи промяната може да е различна), докато не се достигне базов случай.
(define (myFib n)
  (if (or (= n 0) (= n 1))
      1
      (+ (myFib (- n 1)) (myFib (- n 2)))))

; да проследим развитието на процеса:
;    (myFib 3)
; => (+ (myFib 2) (myFib 1))
; => (+ (+ (myFib 1) (myFib 0)) 1)
; => (+ (+ 1 1) 1)
; => (+ 2 1)
; -> 3
; Имаме фаза на "разгъване" (увеличаване на броя операции - тук събиране) и фаза на "сгъване" (намаляване на броя операции).
; Интерпретаторът трябва да запазва формираната верига от операции, за да може по-късно да ги изпълни.

; Иитеративно решение - на всяка стъпка състоянието на изчисленията се описва от "променливи на състоянието" (state variables) и правило, с което може да се премине към следващата стъпка.
; Тук всъшност итеративната част е в helper, а не в главната функция - тя само извиква helper с подходящи аргументи
(define (myFibIter n)
  (define (helper counter prev acc)
    (if (= counter n)
        acc
        (helper (+ counter 1) acc (+ acc prev))))
  (helper 0 0 1))

; Текущите стойности на променливите counter, prev и acc дават пълна информация за текущото състояние.

; prev е съкратено за previous - този аргумент съдържа предишното число на Фибоначи
; acc е съкратено за accumulated - наричаме този аргумент така, тъй като в него "акумулираме" резултата.
; Бихме могли да го кръстим и по-друг начин - current (или curr за по-кратко), тъй като съдържа текущото число на Фибоначи, или пък result (или res).

; да проследим развитието на процеса:
;    (myFibIter 4)
;            counter prev acc
; => (helper 0       0    1)
; => (helper 1       1    1)
; => (helper 2       1    2)
; => (helper 3       2    3)
; => (helper 4       3    5)
; -> 5

; Забележете, че в "итеративния" процес пак има рекурсия - дефиницията на итеративен във Функционалното програмиране не споменава липса на рекурсия.
; В тази парадигма нямаме средствата на императивните езици, така че почти всичко става с рекурсия.

; Защо са ни итеративните решения? Основната причина е ефективност.
; Може да проверим с time - вградена функция, която засича времето за изпълнение.

; примерни резултати от изпълнението
;(time (myFib 40))         ; -> cpu time: 12344 real time: 12737 gc time: 62
;(time (myFibIter 40))     ; -> cpu time: 0 real time: 1 gc time: 0
;(time (myFibIter 40000))  ; -> cpu time: 188 real time: 194 gc time: 125
;(time (myFibIter 400000)) ; -> cpu time: 8000 real time: 8243 gc time: 5531
; Може да се види колко по-бързо е итеративното решение. В случая на Фибоначи, директното рекурсивно решение е изключително бавно, тъй като на всяка стъпка правим по две рекурсивни извиквания.
; В други функции, като например факториел (при която има само едно рекурсивно извикване), рекурсивното решение няма да е толкова бавно, но пак ще е по-бавно от съответното итеративно.



; Упражнение 2:
; Условен оператор cond - позволява повече от 2 случая (за разлика от if-a). Може да го считаме като аналог на if с поредица от else if-ове в С++, или на switch.
(define (conditions x)
  (cond [(< x 0) "negative"]
        [(= x 0) "zero"]
        [(and (> x 1) (< x 1000)) "positive"]
        [else "very big"]))
; Изразите между квадратните скоби се наричат "клаузи". Те се оценяват отгоре-надолу, като ако условния израз в някоя от тях се оцени до истина, се "влиза" в клаузата и се връща стойността на израза вдясно.

; else клаузата винаги се оценява до истина, следователно в нея винаги се влиза. Затова я слагаме накрая, и с нея обработваме последния случай.
; Не е задължителна, но е хубаво да я имаме, за да не изпуснем без да искаме някой случай.

; Ако изпуснем случай, и изпълним функцията с аргумент който попада точно в него, няма да се получи грешка, а функцията просто ще върне #<void> - специална константа за липсата на резултат.
; Това най-вероятно не е нещото което искаме, така че трябва да покриваме всички случаи.

;(conditions -3)   ; -> "negative"
;(conditions 0)    ; -> "zero"
;(conditions 3)    ; -> "positive"
;(conditions 3000) ; -> "very big"

; Може и да подравним изразите - не е задължително, но ги прави по-четими, особено когато тестовете се различават много по дължина - тук третият тест е много по-дълъг от другите.
(define (conditions-aligned x)
  (cond [(< x 0)                  "negative"]
        [(= x 0)                  "zero"]
        [(and (> x 1) (< x 1000)) "positive"]
        [else                     "very big"]))


; Задача 1. Да се дефинира функция (minDivisor n), която намира най-малкия делител на числото n > 1.
(define (minDivisor n)
  (define (helper current)
    (if (= (remainder n current) 0)
        current
        (helper (+ current 1))))
  (helper 2))

;(minDivisor 25) ; -> 5

; Задача 2. Да се дефинира функция (maxDivisor n), която намира най-големия делител на числото n > 1.
; a) решение с помощна функция с два аргумента
(define (maxDivisor n)
  (define (helper current max)
    (cond [(>= current n)              max]
          [(= (remainder n current) 0) (helper (+ current 1) current)]
          [else                        (helper (+ current 1) max)]))
  (helper 2 1))

; това е много често срещана форма на cond - в първия случай проверяваме дали сме завършили (обикновено дали единият аргумент е надвишил някаква стойност) и връщаме резултат,
; във втория проверяваме дали е изпълнено условие и правим рекурсивно извикване,
; а третият ни случай е else, и там обикновено имаме подобно рекурсивно извикване, но с други аргументи, тъй като тук условието от втория случай не е било изпълнено

; b) решение с помощна функция с един аргумент
(define (maxDivisor2 n)
  (define (helper current)
    (if (= (remainder n current) 0)
        current
        (helper (- current 1))))
  (helper (- n 1)))

; c) решение чрез Задача 1.
(define (maxDivisor3 n) (/ n (minDivisor n)))

;(maxDivisor 145)  ; -> 29
;(maxDivisor2 145) ; -> 29
;(maxDivisor3 145) ; -> 29

; Задача 3. Да се дефинира функция (sumOfOdds a b), която намира сумата на нечетните числа в затворения интервал [a, b].
; a) за всяко число от интервала проверяваме дали е нечетно
(define (sumOfOdds a b)
  (define (helper start end acc)
    (cond [(> start end) acc]
          [(odd? start)  (helper (+ start 1) end (+ acc start))]
          [else          (helper (+ start 1) end acc)]))
  (helper a b 0))

; b) като а), но не пазим текущата сума
(define (sumOfOdds2 a b)
  (cond [(> a b)  0]
        [(odd? a) (+ a (sumOfOdds3 (+ a 1) b))]
        [else     (sumOfOdds3 (+ a 1) b)]))

; c) по-ефективно - правим проверка за четност само за началото на интервала, след което просто просто прескачаме четните числа, като обхождаме интервала със стъпка 2 вместо 1
(define (sumOfOdds3 a b)
  (define (helper start end acc)
    (if (> start end)
        acc
        (helper (+ start 2) end (+ acc start))))
  (if (odd? a)
      (helper a b 0)
      (helper (+ a 1) b 0)))

;(sumOfOdds 2 10)  ; -> 24 (3 + 5 + 7 + 9)
;(sumOfOdds 3 14)  ; -> 48

; Задача 4. Да се дефинира функция (leap-year? year), която проверява дали годината year е високосна.
(define (divides? m n) (= 0 (remainder n m)))
(define (leap-year? year)
  (cond [(not (divides? 4 year))   #f]
        [(not (divides? 100 year)) #t]
        [(not (divides? 400 year)) #f]
        [else                      #t]))

; Задача 5. Да се дефинира функция (valid-date? day month year), която проверява дали така зададената дата е валидна.
(define (valid-date? day month year)
  #| (define (valid-year? year)
    (and (<= 1900 year) (<= year 9999))) |#
  ; ние предаваме аргумента year от главната функция към локалната без промяна. Това е излишно - локалната функция "вижда" аргументите на главната, и може да ги достъпи директно
  (define valid-year?
    (and (<= 1900 year) (<= year 9999)))
  ; така предикатът всъщност няма собствени аргументи - той е просто стойност, която се определя от аргументите на главната функция
  (define valid-month?
    (and (<= 1 month) (<= month 12)))

  (define days-in-month
    (cond [(or (= month 1) (= month 3) (= month 5) (= month 7) (= month 8) (= month 10) (= month 12)) 31]
          [(or (= month 4) (= month 6) (= month 9) (= month 11))                                      30]
          [(leap-year? year)                                                                          29]   ; ако не сме влезли в някой от първите 2 случая, значи сме във февруари (или месецът въобще не е валиден, 
          [else                                                                                       28])) ; но това ще се провери от valid-month?. Все пак, ако искаме, може тук да добавим проверка за (= month 2))
  (define valid-day?
    (and (<= 1 day) (<= day days-in-month)))

  (and valid-day? valid-month? valid-year?))
  
;(valid-date? 5 5 1998)   ; -> #t
;(valid-date? 29 2 1998)  ; -> #f
;(valid-date? 29 2 1904)  ; -> #t
;(valid-date? 29 2 1905)  ; -> #f
;(valid-date? 31 1 1900)  ; -> #t
;(valid-date? 31 4 1990)  ; -> #f
;(valid-date? 31 13 1900) ; -> #f
;(valid-date? 32 1 1900)  ; -> #f
